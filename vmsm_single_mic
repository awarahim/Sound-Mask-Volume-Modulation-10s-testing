#!/usr/bin/python3
# -*- coding:utf-8 -*-
import pyaudio
import wave

import signal
import sys

import multiprocessing as mp

import numpy as np
import time
from subprocess import call

from datetime import datetime
import wave

import csv

# Stop signal handler by Ctrl-C
stop_event = mp.Event()
# with SSH it doesnt wokrk :(

# Constants for audio devices
FORMAT  = pyaudio.paInt16    # 24-bit the mic is 24-bit with sample rate of 96kHz
CHANNELS = 1                 # number of audio streams to use. Since there is one speaker and one mic, use 2 streams
RATE = 48000                # 48kHz since mic is specific at 48kHz
FRAMES_PER_BUFFER = 1024    # number of frames the speaker is taking in 

# calculate RMS of data chunk
def rms(data):
    if len(data) == 1: return print('data length =1')
    fromType = np.int16
    d = np.frombuffer(data,fromType).astype(np.float) # convert data from buffer from int16 to float to calculate rms
    rms = np.sqrt(np.mean(d**2))
    return abs(int(rms))
    
    
##### Functional functions ######
    
def error_mic(q1, stop_event):
    p = pyaudio.PyAudio()
    print('error mic running...')

    err_data = [] # need to cast to int16
    
    def callback2(in_data2, frame_count2, time_info2, status2):
        data2 = rms(in_data2)
        q2.put(data2)
        err_data.append(data2)

        return in_data2, pyaudio.paContinue
        
    stream = p.open(
        format=FORMAT,
        channels=CHANNELS,
        rate=RATE,
        frames_per_buffer=FRAMES_PER_BUFFER,
        input=True,
        input_device_index=3,
        stream_callback = callback2)
            
    while not stop_event.wait(0.1): # data coming in is really fast, use 1s for the wait
        # start stream
        stream.start_stream()    
    stream.stop_stream()
    print('error mic is stopped')
    stream.close()



#######################################################################################################################################    
# Second Thread for simultaneous calculate the moving average of compiled RMS values
def moving_average(q1, q2, stop_event, window= 10):
    err = []    
    
    time.sleep(0.5) # allow the q's fill up apparently until 7 data points only after 1s, so I put 2s to get more data 
    print('Initial Q1 Q2 size:', q1.qsize(), q2.qsize())

    while q1.qsize()> 0 and not stop_event.wait(0.1):  #check if the qs are not empty
        print('Moving Average Started')        
        # Put first Window-1 to be the same number as non-averaged rms number
        for n in range(0,window):
                err.append(q1.get())
                q2.put(err[n])
                
        #Calculate the mean of first (window)
        Mprev_err = np.mean(err)
        
        # Put the means at the window'th position
        q2.put(Mprev_err)

        #empty buffer
        err = []        
        
        while not stop_event.wait(0.1):
            # Calculate next one step window of the data
            Mnew_err = Mprev_err + (q2.get() - Mprev_err)/window
 
            # New mean becomes the previous mean
            Mprev_err = Mnew_err

            # Save the data in the respective queues
            q2.put(Mprev_err)

    print('Moving Average Stopped')
    
    
    
    
#####################################################################################################################
# Third Thread for simultaneous volume modulation

def vol_diff_calibrate(q2, vol_threshold, stop_event, duration=1*60):
   
    buffer = []
    start = time.time()
    elapsed = 0

    print('calibrating...', datetime.now())

    while elapsed < duration and not stop_event.wait(0.1):
        err_signal = q2.get()
        buffer.append(err_signal)
        current = time.time()
        elapsed = current - start
    mean = abs(np.mean(buffer)) # must only give positive threshold

    vol_threshold = round(mean)
    print('done calibrated threshold:', vol_threshold)

    return vol_threshold

def main_volume_modulation(q2, delta, volume_value, stop_event,vol_threshold, duration, W=10):
    file = datetime.now().strftime('%b_%d_%H_%M_%S_VMSM_single_mic.csv')
    
    time.sleep(1) # wait for moving average to complete calculate and put data into q3 and q4
    
    vol_threshold.value = vol_diff_calibrate(q3,q4, vol_threshold.value, stop_event, duration)
    
#     time.sleep(1)
    print('volume modulation started')
    
    current_volume = volume_value.value # initializes current volume
    
    while q2.qsize()> 0 and not stop_event.wait(0.1):
        err_signal = q2.get()
        
        # "Learning rate" / "sensitivity" of volume adjustment
        delta = delta # The larger this number, the longer it should take to reach the target volume
        nu = abs(err_signal / delta)
        volume_value.value = comparator(file, err_signal, current_volume, W, vol_threshold.value, nu)
#         logging.info('volume step size:' + str(nu))
        
        current_volume = volume_value.value # set the "current_volume" in modulating_volume function into new_volume because we always get 21, 19, 20
        
        print('volume modulation stopped')
    
def comparator(file, signal, current_vol, window=10, v_threshold=100, nu=1):
    # nu : the step size of volume being increased or decreased, in percent, ex: 1 = 1%
    # v_threshold : upper limit of the difference between the mics values
    # return: new volume
    # new volume must not be more than 100 and less than 10
    
    #initialize new volume
    new_vol = current_vol
    
    # signal within the buffer range
    if signal >=( -v_threshold-10.0)  and signal <= (v_threshold+10.0):
       new_vol = current_vol
       print('same baseline, calc volume:', new_vol, 'difference', difference)
 
    elif signal < (-v_threshold-10.0): # signal decreased in amplitude above buffer range
        new_vol = current_vol + nu
        print('ref smaller, calc volume:', new_vol, 'difference:', difference)
    
    elif signal > (v_threshold+10.0): # signal increased in amplitude above buffer range
        new_vol = current_vol - nu
        print('error smaller, calc volume:', new_vol, 'difference', difference)
    
    # Limit volume to be within [5,100] percent
    if new_vol <5:
        new_vol = 5
        print('volume lowered to minimum 5')

    elif new_vol > 100:
        new_vol = 100
        print('volume maxed to 100')
        
    #   save data of volume difference in csv file
    file = open(file,'a')
    writer = csv.writer(file)
    writer.writerow([time.time(), signal, new_vol])
    file.close()
    
    return new_vol
################################################################################################################################################    
# Generating White Noise, y(n)

# NONBLOCKING MODE    
def whitenoise(volume_value, stop_event):
    
     ##### minimum needed to read a wave #############################
     # open the file for reading.
    WF = wave.open('BrownNoise_60s.wav', 'rb')
    
    
#     print('volume value', volume_value.value)
     
    def callback_speaker(in_data, frame_count, time_info, status):
#          volume_value.value = (volume_value.value + 1) % 100
         data = WF.readframes(frame_count)
#         tic = time.time()
         data = set_volume(data,volume_value.value)
#         toc = time.time() - tic
#         print('time taken to set volume:', toc)
         return data, pyaudio.paContinue
     
     #create an audio object
    p2 = pyaudio.PyAudio()
     
     # open stream based on the wave object which has been input
    stream3 = p2.open(format=p2.get_format_from_width(WF.getsampwidth()),
                     channels = WF.getnchannels(),
                     rate = WF.getframerate(),
                     output=True,
                     output_device_index=1,
                     stream_callback=callback_speaker)
#     
#     
     # start stream
    while not stop_event.wait(0.1):
        stream3.start_stream()         
         # control how long the stream to play
        time.sleep(10)
        WF.rewind()  
         
    stream3.stop_stream()

    # cleanup stuff
    stream3.close()
     
    WF.close()
      
    print('Speaker completely stopped at ', datetime.now())
    
    
    
def set_volume(datalist,volume):
    """ Change value of list of audio chunks """

    if volume >= 0 and volume <= 100: #only changes the volume when volume is within [0,100]
    
        sound_level = (volume / 100.)
            
        fromType = np.int16
        chunk = np.frombuffer(datalist,fromType).astype(np.float) 

        chunk = chunk * sound_level
    #     print(chunk)
        
        datalist = chunk.astype(np.int16)
    #     print(datalist)
#     elif volume < 0:
#         sound_level = (5/100.0)
#         fromType = np.int16
#         chunk = np.frombuffer(datalist,fromType).astype(np.float)
#         chunk = chunk*sound_level
#         datalist = chunk.astype(np.int16)
#     
#     elif volume > 100:
#         sound_level = (100/100.)
#         fromType = np.int16
#         chunk = np.frombuffer(datalist,fromType).astype(np.float)
#         chunk = chunk*sound_level
#         datalist = chunk.astype(np.int16)
        
    return datalist


###########################################################################################
def stop(signum, frame):
    global stop_event
    print('KeyboardInterrupt ', datetime.now())
    stop_event.set()


############################# Main code ###################################################
def thread_mask():    

    # os shutdown
    #signal.signal(signal.SIGTERM, stop)
    # ctrl-c
    signal.signal(signal.SIGINT, stop)
    
    print('Enter window size:')
    window = int(input())
    print('Enter max_size:')
    maxsize = int(input())
    print('Enter delta:')
    delta = int(input())
    logging.info('delta:' + str(delta))
    
    vol_threshold = mp.Value('d', 10.0) # initial value of threshold value
    calibrate_duration = 3*60 # in seconds
    volume_value = mp.Value('d', 10.0)
    
    q1 = mp.Queue(maxsize)
    q2 = mp.Queue(maxsize)
    
    print('Start at ', datetime.now())
    

    p1 = mp.Process(target=error_mic, args=(q1,stop_event))
    p2 = mp.Process(target=whitenoise, args=(volume_value, stop_event))
    p3 = mp.Process(target=moving_average, args=(q1, q2, stop_event, window))
    p4 = mp.Process(target=main_volume_modulation, args = (q2, delta,volume_value, stop_event,vol_threshold, calibrate_duration, window))
    
    p1.start()
    p2.start()
    p3.start()
    p4.start()
    
    
    p1.join()
    p2.join()
    p3.join()
    p4.join() 

    print('Ended at ', datetime.now())
    
#######################################################################################################
   
if __name__ == '__main__':
    thread_mask()
    


## Notes
    # timeout for stop_event.wait(0.1) must be the same for all functions for volume modulation to not have pre-termination.
    # Does timeout cause data to be collected every 0.1s or previously 0.5s? Yes. and stop_event.wait(cannot be blank) 

